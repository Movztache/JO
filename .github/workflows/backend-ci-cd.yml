# ============================================================================
# PIPELINE CI/CD GITHUB ACTIONS - BACKEND SPRING BOOT VIBE-TICKETS
# ============================================================================
#
# Ce pipeline automatise le dÃ©ploiement complet du backend Spring Boot :
#
# DÃ‰CLENCHEURS :
# - Push sur la branche main (dÃ©ploiement automatique)
# - Push sur les branches feature/* (tests uniquement)
# - Pull Requests vers main (tests et validation)
#
# Ã‰TAPES CI (Continuous Integration) :
# 1. Checkout du code source
# 2. Configuration de Java 21 et Maven
# 3. Cache des dÃ©pendances Maven pour optimiser les builds
# 4. Tests unitaires et d'intÃ©gration
# 5. Build de l'application Spring Boot
# 6. CrÃ©ation de l'image Docker avec tag timestamp
# 7. Tests de sÃ©curitÃ© et qualitÃ© du code
#
# Ã‰TAPES CD (Continuous Deployment) - UNIQUEMENT SUR MAIN :
# 8. Authentification AWS et push vers ECR
# 9. Mise Ã  jour des variables Terraform
# 10. DÃ©ploiement de l'infrastructure avec Terraform
# 11. Health checks et validation du dÃ©ploiement
# 12. Notification du statut de dÃ©ploiement
#
# SÃ‰CURITÃ‰ :
# - Utilisation de secrets GitHub pour les credentials AWS
# - Scan de sÃ©curitÃ© des images Docker
# - Validation des variables d'environnement
# - Isolation des environnements (dev/staging/prod)
#
# ============================================================================

name: ðŸš€ Backend CI/CD Pipeline

# ============================================================================
# CONFIGURATION DES DÃ‰CLENCHEURS
# ============================================================================
on:
  # DÃ©clenchement automatique sur push vers main (dÃ©ploiement complet)
  push:
    branches: 
      - main
      - develop
    # Filtrer uniquement les changements affectant le backend
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - 'terraform/**'
      - 'scripts/**'
      - '.github/workflows/backend-ci-cd.yml'

  # DÃ©clenchement sur Pull Requests (tests uniquement, pas de dÃ©ploiement)
  pull_request:
    branches: 
      - main
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - '.github/workflows/backend-ci-cd.yml'

  # DÃ©clenchement manuel avec paramÃ¨tres personnalisables
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de dÃ©ploiement'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Ignorer les tests (dÃ©conseillÃ© pour prod)'
        required: false
        default: false
        type: boolean

# ============================================================================
# VARIABLES D'ENVIRONNEMENT GLOBALES
# ============================================================================
env:
  # Configuration AWS
  AWS_REGION: eu-west-3
  ECR_REPOSITORY: vibe-tickets
  
  # Configuration Java et Maven
  JAVA_VERSION: '21'
  MAVEN_OPTS: '-Xmx1024m -XX:MetaspaceSize=256m'
  
  # Configuration Docker
  DOCKER_BUILDKIT: 1
  
  # Configuration Terraform
  TF_VERSION: '1.6.0'
  TF_VAR_aws_region: eu-west-3

# ============================================================================
# DÃ‰FINITION DES JOBS
# ============================================================================
jobs:
  # ==========================================================================
  # JOB 1: TESTS ET VALIDATION (CI)
  # ==========================================================================
  test-and-build:
    name: ðŸ§ª Tests et Build
    runs-on: ubuntu-latest
    
    # Configuration des services pour les tests d'intÃ©gration
    services:
      # Base de donnÃ©es PostgreSQL pour les tests d'intÃ©gration
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: vibe_tickets_test
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      # ----------------------------------------------------------------------
      # Ã‰TAPE 1: RÃ©cupÃ©ration du code source
      # ----------------------------------------------------------------------
      - name: ðŸ“¥ Checkout du code source
        uses: actions/checkout@v4
        with:
          # RÃ©cupÃ©rer tout l'historique pour les analyses de qualitÃ©
          fetch-depth: 0

      # ----------------------------------------------------------------------
      # Ã‰TAPE 2: Configuration de l'environnement Java
      # ----------------------------------------------------------------------
      - name: â˜• Configuration de Java ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          
      # ----------------------------------------------------------------------
      # Ã‰TAPE 3: Cache des dÃ©pendances Maven
      # ----------------------------------------------------------------------
      - name: ðŸ“¦ Cache des dÃ©pendances Maven
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # ----------------------------------------------------------------------
      # Ã‰TAPE 4: Validation et compilation
      # ----------------------------------------------------------------------
      - name: ðŸ” Validation du projet Maven
        run: |
          echo "ðŸ” Validation de la structure du projet..."
          mvn validate
          
          echo "ðŸ“‹ Informations sur le projet:"
          mvn help:effective-pom -q
          
          echo "ðŸ“¦ DÃ©pendances du projet:"
          mvn dependency:tree

      - name: ðŸ—ï¸ Compilation du code source
        run: |
          echo "ðŸ—ï¸ Compilation du code source..."
          mvn clean compile -B
          
          echo "âœ… Compilation terminÃ©e avec succÃ¨s"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 5: ExÃ©cution des tests
      # ----------------------------------------------------------------------
      - name: ðŸ§ª Tests unitaires
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "ðŸ§ª ExÃ©cution des tests unitaires..."
          mvn test -B

          echo "ðŸ“Š GÃ©nÃ©ration du rapport de couverture..."
          mvn jacoco:report
        env:
          # Configuration pour les tests avec base de donnÃ©es
          SPRING_PROFILES_ACTIVE: test
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/vibe_tickets_test
          SPRING_DATASOURCE_USERNAME: test_user
          SPRING_DATASOURCE_PASSWORD: test_password

      # ----------------------------------------------------------------------
      # Ã‰TAPE 6: Build de l'application
      # ----------------------------------------------------------------------
      - name: ðŸ“¦ Build de l'application
        run: |
          echo "ðŸ“¦ Build de l'application Spring Boot..."
          mvn package -DskipTests -B
          
          echo "ðŸ“‹ Informations sur l'artefact gÃ©nÃ©rÃ©:"
          ls -la target/*.jar
          
          echo "âœ… Build terminÃ© avec succÃ¨s"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 7: Upload des artefacts pour les jobs suivants
      # ----------------------------------------------------------------------
      - name: ðŸ“¤ Upload de l'artefact JAR
        uses: actions/upload-artifact@v4
        with:
          name: vibe-tickets-jar
          path: target/*.jar
          retention-days: 1

      # ----------------------------------------------------------------------
      # Ã‰TAPE 8: Upload des rapports de tests
      # ----------------------------------------------------------------------
      - name: ðŸ“Š Upload des rapports de tests
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: |
            target/surefire-reports/**/*
            target/site/jacoco/**/*
          retention-days: 7
          if-no-files-found: warn

  # ==========================================================================
  # JOB 2: BUILD ET PUSH DOCKER (CI)
  # ==========================================================================
  docker-build:
    name: ðŸ³ Build Docker
    runs-on: ubuntu-latest
    needs: test-and-build
    
    # Variables spÃ©cifiques Ã  ce job
    env:
      IMAGE_TAG: v$(date +%Y%m%d-%H%M%S)
    
    outputs:
      # Exposer le tag de l'image pour les jobs suivants
      image-tag: ${{ steps.generate-tag.outputs.tag }}
      ecr-uri: ${{ steps.generate-tag.outputs.ecr-uri }}

    steps:
      # ----------------------------------------------------------------------
      # Ã‰TAPE 1: RÃ©cupÃ©ration du code et des artefacts
      # ----------------------------------------------------------------------
      - name: ðŸ“¥ Checkout du code source
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download de l'artefact JAR
        uses: actions/download-artifact@v4
        with:
          name: vibe-tickets-jar
          path: target/

      # ----------------------------------------------------------------------
      # Ã‰TAPE 2: GÃ©nÃ©ration du tag avec timestamp
      # ----------------------------------------------------------------------
      - name: ðŸ·ï¸ GÃ©nÃ©ration du tag Docker
        id: generate-tag
        run: |
          # GÃ©nÃ©ration du timestamp au format utilisÃ© par le projet
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="v${TIMESTAMP}"
          
          # Construction de l'URI ECR complÃ¨te
          ECR_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          
          echo "ðŸ·ï¸ Tag gÃ©nÃ©rÃ©: ${IMAGE_TAG}"
          echo "ðŸ·ï¸ URI ECR: ${ECR_URI}"
          
          # Export des variables pour les Ã©tapes suivantes
          echo "tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
          echo "ecr-uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> "$GITHUB_ENV"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 3: Configuration de Docker Buildx
      # ----------------------------------------------------------------------
      - name: ðŸ”§ Configuration de Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          # Utiliser le driver docker-container pour les fonctionnalitÃ©s avancÃ©es
          driver: docker-container

      # ----------------------------------------------------------------------
      # Ã‰TAPE 4: Build de l'image Docker
      # ----------------------------------------------------------------------
      - name: ðŸ³ Build de l'image Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: |
            vibe-tickets:${{ steps.generate-tag.outputs.tag }}
            vibe-tickets:latest
          # Optimisations pour le cache
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Build multi-plateforme si nÃ©cessaire
          platforms: linux/amd64

      # ----------------------------------------------------------------------
      # Ã‰TAPE 5: Tests de sÃ©curitÃ© de l'image Docker
      # ----------------------------------------------------------------------
      - name: ðŸ”’ Scan de sÃ©curitÃ© de l'image Docker
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: vibe-tickets:${{ steps.generate-tag.outputs.tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: ðŸ“¤ Upload des rÃ©sultats de sÃ©curitÃ©
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ==========================================================================
  # JOB 3: DÃ‰PLOIEMENT AWS (CD) - UNIQUEMENT SUR MAIN
  # ==========================================================================
  deploy-aws:
    name: ðŸš€ DÃ©ploiement AWS
    runs-on: ubuntu-latest
    needs: [test-and-build, docker-build]

    # ExÃ©cuter uniquement sur la branche main et si ce n'est pas une PR
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    # DÃ©finir l'environnement pour les secrets et protections
    environment:
      name: ${{ inputs.environment || 'dev' }}
      url: http://${{ steps.deploy.outputs.ec2-ip }}:8080

    steps:
      # ----------------------------------------------------------------------
      # Ã‰TAPE 1: RÃ©cupÃ©ration du code source
      # ----------------------------------------------------------------------
      - name: ðŸ“¥ Checkout du code source
        uses: actions/checkout@v4

      # ----------------------------------------------------------------------
      # Ã‰TAPE 2: Configuration des credentials AWS
      # ----------------------------------------------------------------------
      - name: ðŸ” Configuration des credentials AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # Masquer les credentials dans les logs
          mask-aws-account-id: true

      # ----------------------------------------------------------------------
      # Ã‰TAPE 3: VÃ©rification des permissions AWS
      # ----------------------------------------------------------------------
      - name: âœ… VÃ©rification des permissions AWS
        run: |
          echo "ðŸ” VÃ©rification de l'identitÃ© AWS..."
          aws sts get-caller-identity

          echo "ðŸ” VÃ©rification de l'accÃ¨s ECR..."
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} || {
            echo "âŒ Repository ECR non trouvÃ© ou permissions insuffisantes"
            exit 1
          }

          echo "âœ… Permissions AWS validÃ©es"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 4: Authentification Docker vers ECR
      # ----------------------------------------------------------------------
      - name: ðŸ³ Authentification Docker vers ECR
        run: |
          echo "ðŸ” Authentification vers ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin \
            ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

          echo "âœ… Authentification ECR rÃ©ussie"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 5: Reconstruction et push de l'image Docker
      # ----------------------------------------------------------------------
      - name: ðŸ“¥ Download de l'artefact JAR
        uses: actions/download-artifact@v4
        with:
          name: vibe-tickets-jar
          path: target/

      - name: ðŸ³ Build et Push vers ECR
        run: |
          IMAGE_TAG="${{ needs.docker-build.outputs.image-tag }}"
          ECR_URI="${{ needs.docker-build.outputs.ecr-uri }}"

          echo "ðŸ—ï¸ Build de l'image Docker pour ECR..."
          docker build -t vibe-tickets:${IMAGE_TAG} .

          echo "ðŸ·ï¸ Tag de l'image pour ECR..."
          docker tag vibe-tickets:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}
          docker tag vibe-tickets:${IMAGE_TAG} ${ECR_URI}:latest

          echo "ðŸ“¤ Push vers ECR..."
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest

          echo "âœ… Image pushÃ©e avec succÃ¨s vers ECR"
          echo "ðŸ“‹ Tag utilisÃ©: ${IMAGE_TAG}"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 6: Installation et configuration de Terraform
      # ----------------------------------------------------------------------
      - name: ðŸ—ï¸ Installation de Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          # Permettre l'accÃ¨s aux outputs Terraform
          terraform_wrapper: false

      # ----------------------------------------------------------------------
      # Ã‰TAPE 7: GÃ©nÃ©ration des clÃ©s SSH pour EC2
      # ----------------------------------------------------------------------
      - name: ðŸ”‘ GÃ©nÃ©ration des clÃ©s SSH
        run: |
          echo "ðŸ”‘ GÃ©nÃ©ration des clÃ©s SSH pour EC2..."

          # GÃ©nÃ©ration du nom de clÃ© avec timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SSH_KEY_NAME="vibe-tickets-key-${TIMESTAMP}"

          # GÃ©nÃ©ration de la paire de clÃ©s
          ssh-keygen -t rsa -b 4096 -f terraform/ssh-key -N "" -C "vibe-tickets-${TIMESTAMP}"

          # Permissions correctes pour la clÃ© privÃ©e
          chmod 600 terraform/ssh-key
          chmod 644 terraform/ssh-key.pub

          echo "âœ… ClÃ©s SSH gÃ©nÃ©rÃ©es: ${SSH_KEY_NAME}"
          echo "SSH_KEY_NAME=${SSH_KEY_NAME}" >> $GITHUB_ENV

      # ----------------------------------------------------------------------
      # Ã‰TAPE 8: Mise Ã  jour des variables Terraform
      # ----------------------------------------------------------------------
      - name: ðŸ“ Mise Ã  jour des variables Terraform
        run: |
          cd terraform

          IMAGE_TAG="${{ needs.docker-build.outputs.image-tag }}"

          echo "ðŸ“ Mise Ã  jour de terraform.tfvars..."

          # Mise Ã  jour du tag d'image
          sed -i "s/^image_tag = .*/image_tag = \"${IMAGE_TAG}\"/" terraform.tfvars

          # Mise Ã  jour du nom de clÃ© SSH
          sed -i "s/^ec2_key_name = .*/ec2_key_name = \"${SSH_KEY_NAME}\"/" terraform.tfvars

          echo "ðŸ“‹ Variables Terraform mises Ã  jour:"
          grep -E "^(image_tag|ec2_key_name)" terraform.tfvars

          echo "âœ… Variables Terraform configurÃ©es"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 9: DÃ©ploiement avec Terraform
      # ----------------------------------------------------------------------
      - name: ðŸš€ Initialisation de Terraform
        run: |
          cd terraform
          echo "ðŸ”§ Initialisation de Terraform..."
          terraform init

          echo "ðŸ“‹ Validation de la configuration..."
          terraform validate

          echo "âœ… Terraform initialisÃ© et validÃ©"

      - name: ðŸ“‹ Plan Terraform
        run: |
          cd terraform
          echo "ðŸ“‹ GÃ©nÃ©ration du plan de dÃ©ploiement..."
          terraform plan -detailed-exitcode

          echo "âœ… Plan Terraform gÃ©nÃ©rÃ©"

      - name: ðŸš€ Application Terraform
        id: deploy
        run: |
          cd terraform
          echo "ðŸš€ DÃ©ploiement de l'infrastructure..."
          terraform apply -auto-approve

          # RÃ©cupÃ©ration des outputs importants
          EC2_IP=$(terraform output -raw ec2_public_ip)
          RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
          ECR_URL=$(terraform output -raw ecr_repository_url)

          echo "âœ… DÃ©ploiement Terraform terminÃ©"
          echo "ðŸ“‹ Informations de dÃ©ploiement:"
          echo "   - IP EC2: ${EC2_IP}"
          echo "   - RDS Endpoint: ${RDS_ENDPOINT}"
          echo "   - ECR URL: ${ECR_URL}"

          # Export des outputs pour les Ã©tapes suivantes
          echo "ec2-ip=${EC2_IP}" >> "$GITHUB_OUTPUT"
          echo "rds-endpoint=${RDS_ENDPOINT}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 10: Health Checks et validation du dÃ©ploiement
      # ----------------------------------------------------------------------
      - name: ðŸ¥ Health Checks de l'application
        run: |
          EC2_IP="${{ steps.deploy.outputs.ec2-ip }}"
          APP_URL="http://${EC2_IP}:8080"

          echo "ðŸ¥ VÃ©rification de la santÃ© de l'application..."
          echo "ðŸ“ URL de l'application: ${APP_URL}"

          # Attendre que l'application dÃ©marre (max 5 minutes)
          echo "â³ Attente du dÃ©marrage de l'application..."
          for i in {1..30}; do
            if curl -f -s "${APP_URL}/actuator/health" > /dev/null; then
              echo "âœ… Application dÃ©marrÃ©e avec succÃ¨s (tentative ${i})"
              break
            fi

            if [ $i -eq 30 ]; then
              echo "âŒ Timeout: L'application n'a pas dÃ©marrÃ© dans les temps"
              exit 1
            fi

            echo "â³ Tentative ${i}/30 - En attente..."
            sleep 10
          done

          # VÃ©rification dÃ©taillÃ©e de la santÃ©
          echo "ðŸ” VÃ©rification dÃ©taillÃ©e de la santÃ©..."
          HEALTH_RESPONSE=$(curl -s "${APP_URL}/actuator/health")
          echo "ðŸ“‹ RÃ©ponse health check: ${HEALTH_RESPONSE}"

          # VÃ©rification que la base de donnÃ©es est connectÃ©e
          if echo "${HEALTH_RESPONSE}" | grep -q '"status":"UP"'; then
            echo "âœ… Application en bonne santÃ©"
          else
            echo "âŒ Application en mauvaise santÃ©"
            exit 1
          fi

          # Test des endpoints principaux
          echo "ðŸ§ª Test des endpoints principaux..."

          # Test de l'endpoint des offres
          if curl -f -s "${APP_URL}/api/offers" > /dev/null; then
            echo "âœ… Endpoint /api/offers accessible"
          else
            echo "âš ï¸ Endpoint /api/offers non accessible"
          fi

          echo "âœ… Tous les health checks sont passÃ©s"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 11: Nettoyage des ressources temporaires
      # ----------------------------------------------------------------------
      - name: ðŸ§¹ Nettoyage des ressources temporaires
        if: always()
        run: |
          echo "ðŸ§¹ Nettoyage des clÃ©s SSH temporaires..."
          rm -f terraform/ssh-key terraform/ssh-key.pub

          echo "ðŸ§¹ Nettoyage des images Docker locales..."
          docker system prune -f

          echo "âœ… Nettoyage terminÃ©"

  # ==========================================================================
  # JOB 4: NOTIFICATION ET RAPPORT DE DÃ‰PLOIEMENT
  # ==========================================================================
  notify-deployment:
    name: ðŸ“¢ Notification de dÃ©ploiement
    runs-on: ubuntu-latest
    needs: [test-and-build, docker-build, deploy-aws]
    if: always() && github.ref == 'refs/heads/main'

    steps:
      # ----------------------------------------------------------------------
      # Ã‰TAPE 1: PrÃ©paration du rapport de dÃ©ploiement
      # ----------------------------------------------------------------------
      - name: ðŸ“Š PrÃ©paration du rapport de dÃ©ploiement
        id: report
        run: |
          # DÃ©termination du statut global
          if [[ "${{ needs.test-and-build.result }}" == "success" &&
                "${{ needs.docker-build.result }}" == "success" &&
                "${{ needs.deploy-aws.result }}" == "success" ]]; then
            STATUS="âœ… SUCCÃˆS"
            COLOR="good"
          else
            STATUS="âŒ Ã‰CHEC"
            COLOR="danger"
          fi

          # Informations sur le dÃ©ploiement
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_MSG="${{ github.event.head_commit.message || 'Manual deployment' }}"
          AUTHOR="${{ github.event.head_commit.author.name || github.actor }}"
          IMAGE_TAG="${{ needs.docker-build.outputs.image-tag }}"

          # Nettoyer le message de commit pour Ã©viter les caractÃ¨res problÃ©matiques
          COMMIT_MSG_CLEAN=$(echo "$COMMIT_MSG" | tr -d '\n\r' | sed 's/[^a-zA-Z0-9 ._-]//g')

          echo "status=${STATUS}" >> "$GITHUB_OUTPUT"
          echo "color=${COLOR}" >> "$GITHUB_OUTPUT"
          echo "commit-sha=${COMMIT_SHA:0:7}" >> "$GITHUB_OUTPUT"
          echo "commit-msg=${COMMIT_MSG_CLEAN}" >> "$GITHUB_OUTPUT"
          echo "author=${AUTHOR}" >> "$GITHUB_OUTPUT"
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # Ã‰TAPE 2: CrÃ©ation du rÃ©sumÃ© GitHub
      # ----------------------------------------------------------------------
      - name: ðŸ“‹ RÃ©sumÃ© de dÃ©ploiement GitHub
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸš€ Rapport de DÃ©ploiement Vibe-Tickets Backend

          ## ðŸ“Š Statut Global
          **${{ steps.report.outputs.status }}**

          ## ðŸ“‹ Informations de DÃ©ploiement
          - **Commit**: \`${{ steps.report.outputs.commit-sha }}\`
          - **Auteur**: ${{ steps.report.outputs.author }}
          - **Message**: ${{ steps.report.outputs.commit-msg }}
          - **Tag Docker**: \`${{ steps.report.outputs.image-tag }}\`
          - **Environnement**: ${{ inputs.environment || 'dev' }}

          ## ðŸ” DÃ©tail des Jobs
          | Job | Statut | DurÃ©e |
          |-----|--------|-------|
          | Tests et Build | ${{ needs.test-and-build.result == 'success' && 'âœ…' || 'âŒ' }} | - |
          | Docker Build | ${{ needs.docker-build.result == 'success' && 'âœ…' || 'âŒ' }} | - |
          | DÃ©ploiement AWS | ${{ needs.deploy-aws.result == 'success' && 'âœ…' || 'âŒ' }} | - |

          ## ðŸ”— Liens Utiles
          - **Application**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080
          - **Health Check**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080/actuator/health
          - **API Offers**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080/api/offers

          ---
          *DÃ©ploiement automatisÃ© via GitHub Actions*
          EOF

# ============================================================================
# CONFIGURATION DES PERMISSIONS
# ============================================================================
permissions:
  # Permissions nÃ©cessaires pour le pipeline
  contents: read          # Lecture du code source
  packages: write         # Ã‰criture dans GitHub Packages (si utilisÃ©)
  security-events: write  # Upload des rÃ©sultats de sÃ©curitÃ©
  id-token: write        # Pour l'authentification OIDC (optionnel)
  actions: read          # Lecture des actions et workflows
