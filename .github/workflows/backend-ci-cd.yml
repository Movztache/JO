# ============================================================================
# PIPELINE CI/CD GITHUB ACTIONS - BACKEND SPRING BOOT VIBE-TICKETS
# ============================================================================
#
# Ce pipeline automatise le déploiement complet du backend Spring Boot :
#
# DÉCLENCHEURS :
# - Push sur la branche main (déploiement automatique)
# - Push sur les branches feature/* (tests uniquement)
# - Pull Requests vers main (tests et validation)
#
# ÉTAPES CI (Continuous Integration) :
# 1. Checkout du code source
# 2. Configuration de Java 21 et Maven
# 3. Cache des dépendances Maven pour optimiser les builds
# 4. Tests unitaires et d'intégration
# 5. Build de l'application Spring Boot
# 6. Création de l'image Docker avec tag timestamp
# 7. Tests de sécurité et qualité du code
#
# ÉTAPES CD (Continuous Deployment) - UNIQUEMENT SUR MAIN :
# 8. Authentification AWS et push vers ECR
# 9. Mise à jour des variables Terraform
# 10. Déploiement de l'infrastructure avec Terraform
# 11. Health checks et validation du déploiement
# 12. Notification du statut de déploiement
#
# SÉCURITÉ :
# - Utilisation de secrets GitHub pour les credentials AWS
# - Scan de sécurité des images Docker
# - Validation des variables d'environnement
# - Isolation des environnements (dev/staging/prod)
#
# ============================================================================

name: Backend CI/CD Pipeline

# ============================================================================
# CONFIGURATION DES DÉCLENCHEURS
# ============================================================================
on:
  # Déclenchement automatique sur push vers main (déploiement complet)
  push:
    branches: 
      - main
      - develop
    # Filtrer uniquement les changements affectant le backend
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - 'terraform/**'
      - 'scripts/**'
      - '.github/workflows/backend-ci-cd.yml'

  # Déclenchement sur Pull Requests (tests uniquement, pas de déploiement)
  pull_request:
    branches: 
      - main
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - '.github/workflows/backend-ci-cd.yml'

  # Déclenchement manuel avec paramètres personnalisables
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de déploiement'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Ignorer les tests (déconseillé pour prod)'
        required: false
        default: false
        type: boolean

# ============================================================================
# VARIABLES D'ENVIRONNEMENT GLOBALES
# ============================================================================
env:
  # Configuration AWS
  AWS_REGION: eu-west-3
  ECR_REPOSITORY: vibe-tickets
  
  # Configuration Java et Maven
  JAVA_VERSION: '23'
  MAVEN_OPTS: '-Xmx1024m -XX:MetaspaceSize=256m'
  
  # Configuration Docker
  DOCKER_BUILDKIT: 1
  
  # Configuration Terraform
  TF_VERSION: '1.6.0'
  TF_VAR_aws_region: eu-west-3

# ============================================================================
# DÉFINITION DES JOBS
# ============================================================================
jobs:
  # ==========================================================================
  # JOB 1: TESTS ET VALIDATION (CI)
  # ==========================================================================
  test-and-build:
    name: Tests et Build
    runs-on: ubuntu-latest
    
    # Configuration des services pour les tests d'intégration
    services:
      # Base de données PostgreSQL pour les tests d'intégration
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: vibe_tickets_test
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      # ----------------------------------------------------------------------
      # ÉTAPE 1: Récupération du code source
      # ----------------------------------------------------------------------
      - name: Checkout du code source
        uses: actions/checkout@v4
        with:
          # Récupérer tout l'historique pour les analyses de qualité
          fetch-depth: 0

      # ----------------------------------------------------------------------
      # ÉTAPE 2: Configuration de l'environnement Java
      # ----------------------------------------------------------------------
      - name: Configuration de Java ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          
      # ----------------------------------------------------------------------
      # ÉTAPE 3: Cache des dépendances Maven
      # ----------------------------------------------------------------------
      - name: 📦 Cache des dépendances Maven
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # ----------------------------------------------------------------------
      # ÉTAPE 4: Validation et compilation
      # ----------------------------------------------------------------------
      - name:  Validation du projet Maven
        run: |
          echo " Validation de la structure du projet..."
          mvn validate
          
          echo " Informations sur le projet:"
          mvn help:effective-pom -q
          
          echo " Dépendances du projet:"
          mvn dependency:tree

      - name: Compilation du code source
        run: |
          echo " Compilation du code source..."
          mvn clean compile -B
          
          echo "✅ Compilation terminée avec succès"

      # ----------------------------------------------------------------------
      # ÉTAPE 5: Exécution des tests
      # ----------------------------------------------------------------------
      - name:  Tests unitaires
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "Execution des tests unitaires..."
          mvn test -B
        env:
          # Configuration pour les tests avec base de données
          SPRING_PROFILES_ACTIVE: test
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/vibe_tickets_test
          SPRING_DATASOURCE_USERNAME: test_user
          SPRING_DATASOURCE_PASSWORD: test_password

      # ----------------------------------------------------------------------
      # ÉTAPE 6: Build de l'application
      # ----------------------------------------------------------------------
      - name: 📦 Build de l'application
        run: |
          echo "📦 Build de l'application Spring Boot..."
          mvn package -DskipTests -B
          
          echo "📋 Informations sur l'artefact généré:"
          ls -la target/*.jar
          
          echo "✅ Build terminé avec succès"

      # ----------------------------------------------------------------------
      # ÉTAPE 7: Upload des artefacts pour les jobs suivants
      # ----------------------------------------------------------------------
      - name: Upload de l'artefact JAR
        uses: actions/upload-artifact@v4
        with:
          name: vibe-tickets-jar
          path: target/*.jar
          retention-days: 1

      # ----------------------------------------------------------------------
      # ÉTAPE 8: Upload des rapports de tests
      # ----------------------------------------------------------------------
      - name:  Upload des rapports de tests
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: |
            target/surefire-reports/**/*
            target/site/jacoco/**/*
          retention-days: 7
          if-no-files-found: warn

  # ==========================================================================
  # JOB 2: DÉPLOIEMENT AWS (CD) - UNIQUEMENT SUR MAIN
  # ==========================================================================
  deploy-aws:
    name: Deploiement AWS
    runs-on: ubuntu-latest
    needs: test-and-build

    # Exécuter uniquement sur la branche main et si ce n'est pas une PR
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    # Définir l'environnement pour les secrets et protections
    environment:
      name: ${{ inputs.environment || 'dev' }}
      url: http://${{ steps.deploy.outputs.ec2-ip }}:8080

    outputs:
      # Exposer les informations de déploiement
      ec2-ip: ${{ steps.deploy.outputs.ec2-ip }}
      image-tag: ${{ steps.docker-build.outputs.image-tag }}

    steps:
      # ----------------------------------------------------------------------
      # ÉTAPE 1: Récupération du code source
      # ----------------------------------------------------------------------
      - name:  Checkout du code source
        uses: actions/checkout@v4

      # ----------------------------------------------------------------------
      # ÉTAPE 2: Configuration des credentials AWS
      # ----------------------------------------------------------------------
      - name:  Configuration des credentials AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # Masquer les credentials dans les logs
          mask-aws-account-id: true

      # ----------------------------------------------------------------------
      # ÉTAPE 3: Vérification des permissions AWS
      # ----------------------------------------------------------------------
      - name: ✅ Vérification des permissions AWS
        run: |
          echo " Vérification de l'identité AWS..."
          aws sts get-caller-identity

          echo " Vérification de l'accès ECR..."
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} || {
            echo "❌ Repository ECR non trouvé ou permissions insuffisantes"
            exit 1
          }

          echo "✅ Permissions AWS validées"

      # ----------------------------------------------------------------------
      # ÉTAPE 4: Authentification Docker vers ECR
      # ----------------------------------------------------------------------
      - name:  Authentification Docker vers ECR
        run: |
          echo " Authentification vers ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin \
            ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

          echo "✅ Authentification ECR réussie"

      # ----------------------------------------------------------------------
      # ÉTAPE 5: Reconstruction et push de l'image Docker
      # ----------------------------------------------------------------------
      - name:  Download de l'artefact JAR
        uses: actions/download-artifact@v4
        with:
          name: vibe-tickets-jar
          path: target/

      - name: Build et Push vers ECR
        id: docker-build
        run: |
          # Generation du tag avec timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="v${TIMESTAMP}"
          ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_REPOSITORY="${{ env.ECR_REPOSITORY }}"
          ECR_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}"

          echo "Tag genere: ${IMAGE_TAG}"
          echo "ECR Registry: ${ECR_REGISTRY}"
          echo "ECR Repository: ${ECR_REPOSITORY}"
          echo "ECR URI complete: ${ECR_URI}"

          echo "Build de l'image Docker pour ECR..."
          docker build -t vibe-tickets:${IMAGE_TAG} .

          echo "Tag de l'image pour ECR..."
          docker tag vibe-tickets:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}
          docker tag vibe-tickets:${IMAGE_TAG} ${ECR_URI}:latest

          echo "Push vers ECR..."
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest

          echo "Image pushee avec succes vers ECR"
          echo "Tag utilise: ${IMAGE_TAG}"

          # Export pour les etapes suivantes
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # ÉTAPE 6: Installation et configuration de Terraform
      # ----------------------------------------------------------------------
      - name:  Installation de Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          # Permettre l'accès aux outputs Terraform
          terraform_wrapper: false

      # ----------------------------------------------------------------------
      # ÉTAPE 7: Génération des clés SSH pour EC2
      # ----------------------------------------------------------------------
      - name:  Génération des clés SSH
        run: |
          echo " Génération des clés SSH pour EC2..."

          # Génération du nom de clé avec timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SSH_KEY_NAME="vibe-tickets-key-${TIMESTAMP}"

          # Génération de la paire de clés
          ssh-keygen -t rsa -b 4096 -f terraform/ssh-key -N "" -C "vibe-tickets-${TIMESTAMP}"

          # Permissions correctes pour la clé privée
          chmod 600 terraform/ssh-key
          chmod 644 terraform/ssh-key.pub

          echo "✅ Clés SSH générées: ${SSH_KEY_NAME}"
          echo "SSH_KEY_NAME=${SSH_KEY_NAME}" >> $GITHUB_ENV

      # ----------------------------------------------------------------------
      # ÉTAPE 8: Mise à jour des variables Terraform
      # ----------------------------------------------------------------------
      - name:  Mise à jour des variables Terraform
        run: |
          cd terraform

          IMAGE_TAG="${{ steps.docker-build.outputs.image-tag }}"

          echo " Mise à jour de terraform.tfvars..."

          # Mise à jour du tag d'image
          sed -i "s/^image_tag = .*/image_tag = \"${IMAGE_TAG}\"/" terraform.tfvars

          # Mise à jour du nom de clé SSH
          sed -i "s/^ec2_key_name = .*/ec2_key_name = \"${SSH_KEY_NAME}\"/" terraform.tfvars

          echo " Variables Terraform mises à jour:"
          grep -E "^(image_tag|ec2_key_name)" terraform.tfvars

          echo "✅ Variables Terraform configurées"

      # ----------------------------------------------------------------------
      # ÉTAPE 9: Nettoyage des ressources conflictuelles
      # ----------------------------------------------------------------------
      - name: Nettoyage complet des ressources AWS
        run: |
          echo "=========================================="
          echo "NETTOYAGE COMPLET DES RESSOURCES AWS"
          echo "=========================================="

          # Fonction pour attendre et verifier
          wait_and_verify() {
            echo "Attente de $1 secondes pour la propagation..."
            sleep $1
          }

          # 1. NETTOYAGE DES INSTANCES EC2 ET ELASTIC IPS
          echo "1. Nettoyage des instances EC2..."
          aws ec2 describe-instances --region ${{ env.AWS_REGION }} \
            --filters "Name=tag:Name,Values=*vibe-tickets*" "Name=instance-state-name,Values=running,pending,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' --output text | tr '\t' '\n' | while read instance_id; do
            if [ ! -z "$instance_id" ]; then
              echo "Arret forcé de l'instance: $instance_id"
              aws ec2 terminate-instances --region ${{ env.AWS_REGION }} --instance-ids $instance_id || echo "Erreur arret instance"
            fi
          done

          echo "Suppression des Elastic IPs..."
          aws ec2 describe-addresses --region ${{ env.AWS_REGION }} \
            --query 'Addresses[?Tags[?Key==`Name` && contains(Value, `vibe-tickets`)]].AllocationId' --output text | tr '\t' '\n' | while read alloc_id; do
            if [ ! -z "$alloc_id" ]; then
              echo "Liberation de l'Elastic IP: $alloc_id"
              aws ec2 release-address --region ${{ env.AWS_REGION }} --allocation-id $alloc_id || echo "Erreur liberation EIP"
            fi
          done

          wait_and_verify 30

          # 2. NETTOYAGE DES BASES DE DONNÉES RDS
          echo "2. Nettoyage des bases de données RDS..."
          aws rds describe-db-instances --region ${{ env.AWS_REGION }} \
            --query 'DBInstances[?contains(DBInstanceIdentifier, `vibe-tickets`)].DBInstanceIdentifier' --output text | tr '\t' '\n' | while read db_id; do
            if [ ! -z "$db_id" ]; then
              echo "Suppression de la base de données: $db_id"
              aws rds delete-db-instance --region ${{ env.AWS_REGION }} --db-instance-identifier $db_id --skip-final-snapshot --delete-automated-backups || echo "Erreur suppression DB"
            fi
          done

          echo "Suppression des DB subnet groups..."
          aws rds describe-db-subnet-groups --region ${{ env.AWS_REGION }} \
            --query 'DBSubnetGroups[?contains(DBSubnetGroupName, `vibe-tickets`)].DBSubnetGroupName' --output text | tr '\t' '\n' | while read sg_name; do
            if [ ! -z "$sg_name" ]; then
              echo "Suppression du DB subnet group: $sg_name"
              aws rds delete-db-subnet-group --region ${{ env.AWS_REGION }} --db-subnet-group-name $sg_name || echo "Erreur suppression DB subnet group"
            fi
          done

          wait_and_verify 20

          # 3. NETTOYAGE COMPLET DES VPC ET DÉPENDANCES
          echo "3. Nettoyage complet des VPC..."
          aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} \
            --query 'Vpcs[?Tags[?Key==`Name` && contains(Value, `vibe-tickets`)]].VpcId' --output text | tr '\t' '\n' | while read vpc_id; do
            if [ ! -z "$vpc_id" ]; then
              echo "Nettoyage du VPC: $vpc_id"

              # Supprimer NAT Gateways
              aws ec2 describe-nat-gateways --region ${{ env.AWS_REGION }} --filter "Name=vpc-id,Values=$vpc_id" \
                --query 'NatGateways[?State==`available`].NatGatewayId' --output text | tr '\t' '\n' | while read nat_id; do
                if [ ! -z "$nat_id" ]; then
                  echo "Suppression NAT Gateway: $nat_id"
                  aws ec2 delete-nat-gateway --region ${{ env.AWS_REGION }} --nat-gateway-id $nat_id || echo "Erreur NAT Gateway"
                fi
              done

              # Supprimer les associations EIP
              aws ec2 describe-addresses --region ${{ env.AWS_REGION }} \
                --query 'Addresses[?NetworkInterfaceId!=null].AllocationId' --output text | tr '\t' '\n' | while read alloc_id; do
                if [ ! -z "$alloc_id" ]; then
                  aws ec2 disassociate-address --region ${{ env.AWS_REGION }} --allocation-id $alloc_id || echo "Erreur disassociation"
                  aws ec2 release-address --region ${{ env.AWS_REGION }} --allocation-id $alloc_id || echo "Erreur liberation"
                fi
              done

              # Supprimer les subnets
              aws ec2 describe-subnets --region ${{ env.AWS_REGION }} --filters "Name=vpc-id,Values=$vpc_id" \
                --query 'Subnets[].SubnetId' --output text | tr '\t' '\n' | while read subnet_id; do
                if [ ! -z "$subnet_id" ]; then
                  echo "Suppression subnet: $subnet_id"
                  aws ec2 delete-subnet --region ${{ env.AWS_REGION }} --subnet-id $subnet_id || echo "Erreur subnet"
                fi
              done

              # Supprimer les security groups
              aws ec2 describe-security-groups --region ${{ env.AWS_REGION }} --filters "Name=vpc-id,Values=$vpc_id" \
                --query 'SecurityGroups[?GroupName!=`default`].GroupId' --output text | tr '\t' '\n' | while read sg_id; do
                if [ ! -z "$sg_id" ]; then
                  echo "Suppression security group: $sg_id"
                  aws ec2 delete-security-group --region ${{ env.AWS_REGION }} --group-id $sg_id || echo "Erreur SG"
                fi
              done

              # Supprimer les route tables
              aws ec2 describe-route-tables --region ${{ env.AWS_REGION }} --filters "Name=vpc-id,Values=$vpc_id" \
                --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' --output text | tr '\t' '\n' | while read rt_id; do
                if [ ! -z "$rt_id" ]; then
                  echo "Suppression route table: $rt_id"
                  aws ec2 delete-route-table --region ${{ env.AWS_REGION }} --route-table-id $rt_id || echo "Erreur RT"
                fi
              done

              # Supprimer les internet gateways
              aws ec2 describe-internet-gateways --region ${{ env.AWS_REGION }} --filters "Name=attachment.vpc-id,Values=$vpc_id" \
                --query 'InternetGateways[].InternetGatewayId' --output text | tr '\t' '\n' | while read igw_id; do
                if [ ! -z "$igw_id" ]; then
                  echo "Suppression IGW: $igw_id"
                  aws ec2 detach-internet-gateway --region ${{ env.AWS_REGION }} --internet-gateway-id $igw_id --vpc-id $vpc_id || echo "Erreur detach IGW"
                  aws ec2 delete-internet-gateway --region ${{ env.AWS_REGION }} --internet-gateway-id $igw_id || echo "Erreur delete IGW"
                fi
              done

              # Supprimer le VPC
              echo "Suppression VPC: $vpc_id"
              aws ec2 delete-vpc --region ${{ env.AWS_REGION }} --vpc-id $vpc_id || echo "Erreur VPC"
            fi
          done

          wait_and_verify 30

          # 4. NETTOYAGE DES RESSOURCES IAM
          echo "4. Nettoyage des ressources IAM..."

          # Supprimer les instance profiles
          aws iam list-instance-profiles --query 'InstanceProfiles[?contains(InstanceProfileName, `vibe-tickets`)].InstanceProfileName' --output text | tr '\t' '\n' | while read profile_name; do
            if [ ! -z "$profile_name" ]; then
              echo "Suppression instance profile: $profile_name"
              # Detacher les roles d'abord
              aws iam list-instance-profiles --query "InstanceProfiles[?InstanceProfileName=='$profile_name'].Roles[].RoleName" --output text | tr '\t' '\n' | while read role_name; do
                if [ ! -z "$role_name" ]; then
                  aws iam remove-role-from-instance-profile --instance-profile-name $profile_name --role-name $role_name || echo "Erreur detach role"
                fi
              done
              aws iam delete-instance-profile --instance-profile-name $profile_name || echo "Erreur suppression instance profile"
            fi
          done

          # Supprimer les roles IAM
          aws iam list-roles --query 'Roles[?contains(RoleName, `vibe-tickets`)].RoleName' --output text | tr '\t' '\n' | while read role_name; do
            if [ ! -z "$role_name" ]; then
              echo "Suppression role IAM: $role_name"

              # Supprimer les policies inline
              aws iam list-role-policies --role-name $role_name --query 'PolicyNames[]' --output text | tr '\t' '\n' | while read policy; do
                if [ ! -z "$policy" ]; then
                  aws iam delete-role-policy --role-name $role_name --policy-name "$policy" || echo "Erreur policy inline"
                fi
              done

              # Detacher les policies attachees
              aws iam list-attached-role-policies --role-name $role_name --query 'AttachedPolicies[].PolicyArn' --output text | tr '\t' '\n' | while read policy_arn; do
                if [ ! -z "$policy_arn" ]; then
                  aws iam detach-role-policy --role-name $role_name --policy-arn "$policy_arn" || echo "Erreur detach policy"
                fi
              done

              aws iam delete-role --role-name $role_name || echo "Erreur suppression role"
            fi
          done

          wait_and_verify 10

          # 5. NETTOYAGE DES REPOSITORIES ECR
          echo "5. Nettoyage des repositories ECR..."
          aws ecr describe-repositories --region ${{ env.AWS_REGION }} \
            --query 'repositories[?contains(repositoryName, `vibe-tickets`)].repositoryName' --output text | tr '\t' '\n' | while read repo_name; do
            if [ ! -z "$repo_name" ]; then
              echo "Suppression repository ECR: $repo_name"
              aws ecr delete-repository --region ${{ env.AWS_REGION }} --repository-name $repo_name --force || echo "Erreur ECR"
            fi
          done

          wait_and_verify 10

          # 6. NETTOYAGE DES CLÉS SSH
          echo "6. Nettoyage des clés SSH..."
          aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} \
            --query 'KeyPairs[?contains(KeyName, `vibe-tickets`)].KeyName' --output text | tr '\t' '\n' | while read key_name; do
            if [ ! -z "$key_name" ]; then
              echo "Suppression clé SSH: $key_name"
              aws ec2 delete-key-pair --region ${{ env.AWS_REGION }} --key-name $key_name || echo "Erreur clé SSH"
            fi
          done

          # 7. VERIFICATION FINALE ET COMPTAGE DES VPC
          echo "7. Verification finale..."
          VPC_COUNT=$(aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --query 'length(Vpcs)')
          echo "Nombre total de VPC dans la region: $VPC_COUNT"

          if [ "$VPC_COUNT" -ge 5 ]; then
            echo "ATTENTION: Il reste $VPC_COUNT VPC (limite: 5)"
            echo "Liste des VPC existants:"
            aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --query 'Vpcs[].[VpcId,Tags[?Key==`Name`].Value|[0]]' --output table

            echo "Suppression forcee des VPC les plus anciens..."
            aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --query 'Vpcs[?IsDefault==`false`].VpcId' --output text | tr '\t' '\n' | head -2 | while read vpc_id; do
              if [ ! -z "$vpc_id" ]; then
                echo "Suppression forcee du VPC: $vpc_id"
                # Force cleanup sans verification
                aws ec2 delete-vpc --region ${{ env.AWS_REGION }} --vpc-id $vpc_id || echo "VPC a des dependances"
              fi
            done
          else
            echo "OK: $VPC_COUNT VPC (limite: 5) - Espace disponible"
          fi

          echo "=========================================="
          echo "NETTOYAGE COMPLET TERMINE"
          echo "Attente finale de 30 secondes..."
          echo "=========================================="
          sleep 30

      # ----------------------------------------------------------------------
      # ÉTAPE 10: Déploiement avec Terraform
      # ----------------------------------------------------------------------
      - name: Initialisation de Terraform
        run: |
          cd terraform
          echo " Initialisation de Terraform..."
          terraform init

          echo " Validation de la configuration..."
          terraform validate

          echo "✅ Terraform initialisé et validé"

      - name: Plan Terraform
        run: |
          cd terraform
          echo "Generation du plan de deploiement..."

          # Executer terraform plan sans -detailed-exitcode pour eviter les problemes
          terraform plan

          echo "Plan Terraform genere avec succes"

      - name: Application Terraform
        id: deploy
        run: |
          cd terraform
          echo "🚀 Déploiement de l'infrastructure..."
          terraform apply -auto-approve

          # Récupération des outputs importants
          EC2_IP=$(terraform output -raw ec2_public_ip)
          RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
          ECR_URL=$(terraform output -raw ecr_repository_url)

          echo "✅ Déploiement Terraform terminé"
          echo " Informations de déploiement:"
          echo "   - IP EC2: ${EC2_IP}"
          echo "   - RDS Endpoint: ${RDS_ENDPOINT}"
          echo "   - ECR URL: ${ECR_URL}"

          # Export des outputs pour les étapes suivantes
          echo "ec2-ip=${EC2_IP}" >> "$GITHUB_OUTPUT"
          echo "rds-endpoint=${RDS_ENDPOINT}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # ÉTAPE 11: Health Checks et validation du déploiement
      # ----------------------------------------------------------------------
      - name: Health Checks de l'application
        run: |
          EC2_IP="${{ steps.deploy.outputs.ec2-ip }}"
          APP_URL="http://${EC2_IP}:8080"

          echo " Vérification de la santé de l'application..."
          echo " URL de l'application: ${APP_URL}"

          # Attendre que l'application démarre (max 5 minutes)
          echo "⏳ Attente du démarrage de l'application..."
          for i in {1..30}; do
            if curl -f -s "${APP_URL}/actuator/health" > /dev/null; then
              echo "✅ Application démarrée avec succès (tentative ${i})"
              break
            fi

            if [ $i -eq 30 ]; then
              echo "❌ Timeout: L'application n'a pas démarré dans les temps"
              exit 1
            fi

            echo "⏳ Tentative ${i}/30 - En attente..."
            sleep 10
          done

          # Vérification détaillée de la santé
          echo " Vérification détaillée de la santé..."
          HEALTH_RESPONSE=$(curl -s "${APP_URL}/actuator/health")
          echo " Réponse health check: ${HEALTH_RESPONSE}"

          # Vérification que la base de données est connectée
          if echo "${HEALTH_RESPONSE}" | grep -q '"status":"UP"'; then
            echo "✅ Application en bonne santé"
          else
            echo "❌ Application en mauvaise santé"
            exit 1
          fi

          # Test des endpoints principaux
          echo "🧪 Test des endpoints principaux..."

          # Test de l'endpoint des offres
          if curl -f -s "${APP_URL}/api/offers" > /dev/null; then
            echo "✅ Endpoint /api/offers accessible"
          else
            echo "⚠️ Endpoint /api/offers non accessible"
          fi

          echo "✅ Tous les health checks sont passés"

      # ----------------------------------------------------------------------
      # ÉTAPE 12: Nettoyage des ressources temporaires
      # ----------------------------------------------------------------------
      - name: Nettoyage des ressources temporaires
        if: always()
        run: |
          echo "🧹 Nettoyage des clés SSH temporaires..."
          rm -f terraform/ssh-key terraform/ssh-key.pub

          echo "🧹 Nettoyage des images Docker locales..."
          docker system prune -f

          echo "✅ Nettoyage terminé"

  # ==========================================================================
  # JOB 4: NOTIFICATION ET RAPPORT DE DÉPLOIEMENT
  # ==========================================================================
  notify-deployment:
    name: Notification de déploiement
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy-aws]
    if: always() && github.ref == 'refs/heads/main'

    steps:
      # ----------------------------------------------------------------------
      # ÉTAPE 1: Préparation du rapport de déploiement
      # ----------------------------------------------------------------------
      - name: Préparation du rapport de déploiement
        id: report
        run: |
          # Détermination du statut global
          if [[ "${{ needs.test-and-build.result }}" == "success" &&
                "${{ needs.deploy-aws.result }}" == "success" ]]; then
            STATUS="✅ SUCCÈS"
            COLOR="good"
          else
            STATUS="❌ ÉCHEC"
            COLOR="danger"
          fi

          # Informations sur le déploiement
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_MSG="${{ github.event.head_commit.message || 'Manual deployment' }}"
          AUTHOR="${{ github.event.head_commit.author.name || github.actor }}"
          IMAGE_TAG="${{ needs.deploy-aws.outputs.image-tag }}"

          # Nettoyer le message de commit pour éviter les caractères problématiques
          COMMIT_MSG_CLEAN=$(echo "$COMMIT_MSG" | tr -d '\n\r' | sed 's/[^a-zA-Z0-9 ._-]//g')

          echo "status=${STATUS}" >> "$GITHUB_OUTPUT"
          echo "color=${COLOR}" >> "$GITHUB_OUTPUT"
          echo "commit-sha=${COMMIT_SHA:0:7}" >> "$GITHUB_OUTPUT"
          echo "commit-msg=${COMMIT_MSG_CLEAN}" >> "$GITHUB_OUTPUT"
          echo "author=${AUTHOR}" >> "$GITHUB_OUTPUT"
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # ÉTAPE 2: Création du résumé GitHub
      # ----------------------------------------------------------------------
      - name: Résumé de déploiement GitHub
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 🚀 Rapport de Déploiement Vibe-Tickets Backend

          ## Statut Global
          **${{ steps.report.outputs.status }}**

          ## Informations de Déploiement
          - **Commit**: \`${{ steps.report.outputs.commit-sha }}\`
          - **Auteur**: ${{ steps.report.outputs.author }}
          - **Message**: ${{ steps.report.outputs.commit-msg }}
          - **Tag Docker**: \`${{ steps.report.outputs.image-tag }}\`
          - **Environnement**: ${{ inputs.environment || 'dev' }}

          ## Détail des Jobs
          | Job | Statut | Durée |
          |-----|--------|-------|
          | Tests et Build | ${{ needs.test-and-build.result == 'success' && '✅' || '❌' }} | - |
          | Déploiement AWS | ${{ needs.deploy-aws.result == 'success' && '✅' || '❌' }} | - |

          ## 🔗 Liens Utiles
          - **Application**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080
          - **Health Check**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080/actuator/health
          - **API Offers**: http://${{ needs.deploy-aws.outputs.ec2-ip }}:8080/api/offers

          ---
          *Déploiement automatisé via GitHub Actions*
          EOF

# ============================================================================
# CONFIGURATION DES PERMISSIONS
# ============================================================================
permissions:
  # Permissions nécessaires pour le pipeline
  contents: read          # Lecture du code source
  packages: write         # Écriture dans GitHub Packages (si utilisé)
  security-events: write  # Upload des résultats de sécurité
  id-token: write        # Pour l'authentification OIDC (optionnel)
  actions: read          # Lecture des actions et workflows
